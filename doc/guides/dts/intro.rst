.. _devicetree-intro:

Introduction to devicetree
##########################

This page provides an introduction to :ref:`devicetree` and how it is used in
Zephyr.

The following figure shows how devicetree is used by Zephyr's build system:

.. figure:: zephyr_dt_build_flow.png
   :figclass: align-center

   Devicetree build flow

Zephyr's build system generates C preprocessor macros from devicetree
definitions. These macros can be referenced in :ref:`device drivers
<device_drivers>` and other C code. All macro identifiers that are directly
generated by the devicetree scripts start with ``DT_*``.

Some devicetree-related identifiers also start with ``CONFIG_*``, which is the
identifier prefix used by :ref:`Kconfig <kconfig>`. This happens when
devicetree-related information is referenced from Kconfig symbol definitions,
via the :ref:`Kconfig preprocessor <kconfig-functions>`.

This differs significantly from how devicetree is used on Linux. The
Linux kernel would instead read the entire devicetree data structure in its
binary form, parsing it at runtime in order to load and initialize device
drivers. Zephyr does not work this way because the size of the devicetree
binary and associated handling code would be too large to fit comfortably on
the relatively constrained devices Zephyr supports.

Syntax and structure
********************

As the name indicates, a devicetree is a tree. The human-readable text format
for this tree is called DTS (for devicetree source), and is defined in the
`Devicetree specification`_.

.. _Devicetree specification: https://www.devicetree.org/

Here is an example DTS file:

.. code-block:: none

   /dts-v1/;

   / {
           a-node {
                   subnode_label: a-sub-node {
                           foo = <3>;
                   };
           };
   };

This example has three nodes:

#. A root node
#. A node named ``a-node``, which is a child of the root node
#. A node named ``a-sub-node``, which is a child of ``a-node``

Nodes can be given *labels*, which are unique shorthands that can be used to
refer to the labeled node elsewhere in the devicetree. Above, ``a-sub-node``
has label ``subnode_label``.

Devicetree nodes have *paths* identifying their locations in the tree. Like
Unix file system paths, devicetree paths are strings separated by slashes
(``/``), and the root node's path is a single slash: ``/``. Otherwise, each
node's path is formed by concatenating the node's ancestors' names with the
node's own name, separated by slashes. For example, the full path to
``a-sub-node`` is ``/a-node/a-sub-node``.

Devicetree nodes can also have *properties*. Properties are name/value
pairs. The values are simple byte arrays. Node ``a-sub-node`` has a property
named ``foo``, whose value is a 32-bit big-endian unsigned integer with value
3. The size and type of ``foo``\ 's value are implied by the enclosing angle
brackets (``<`` and ``>``) in the DTS. Refer to the Devicetree Specification
for a complete list of ways to write a property value in a DTS file.

In practice, devicetree nodes correspond to some hardware, and the node
hierarchy reflects the hardware's physical layout. For example, let's consider
a board with three I2C peripherals connected to an I2C bus master on an SoC,
like this:

.. figure:: zephyr_dt_i2c_high_level.png
   :alt: representation of a board with three I2C peripherals
   :figclass: align-center

Nodes corresponding to the I2C bus master and each I2C peripheral would be
present in this board's devicetree. Reflecting the hardware layout, the
devicetree's peripheral nodes would be children of the bus master node. Similar
conventions exist for representing other types of hardware in devicetree.

The corresponding DTS would look something like this:

.. code-block:: none

   / {
           soc {
                   i2c-bus-master {
                           i2c-peripheral-1 {
                           };
                           i2c-peripheral-2 {
                           };
                           i2c-peripheral-3 {
                           };
                   };
           };
   };

Properties are used in practice to describe or configure the hardware the node
represents. For example, an I2C peripheral's node has a property whose value is
the peripheral's address on the bus.

Here's a tree representing the same example, but with real-world node
names and properties you might see when working with I2C devices.

.. figure:: zephyr_dt_i2c_example.png
   :figclass: align-center

   I2C devicetree example with real-world names and properties

Above, node names -- like ``i2c@40003000`` -- are at the top of each node, with
a gray background, except for the root node, which is shown using its path
``/``. Properties are shown as ``name=value`` pairs below the node names.

Some important properties are:

compatible
    Says what kind of device the node represents. The value is a
    string in the format "vendor,device", like ``"avago,apds9960"``, or a
    sequence of these, like ``"ti,hdc", "ti,hdc1010"``. The build system uses
    the compatible property to find the right :ref:`binding <dt-bindings>` for
    the node.

label
    The device's name according to Zephyr's :ref:`device_drivers`. The value
    can be passed to :c:func:`device_get_binding()` to retrieve the
    corresponding driver-level :ref:`struct device* <device_struct>`. This
    pointer can then be passed to the correct driver API by application code to
    interact with the device. For example, calling
    ``device_get_binding("I2C_0")`` would return a pointer to a device
    structure which could be passed to :ref:`I2C API <i2c_api>` functions like
    :c:func:`i2c_transfer()`. The generated C header will also contain a macro
    which expands to this string.

reg
    Information used to address the device. This could be a memory-mapped I/O
    address range (as with ``i2c@40003000``\ 's reg property), an I2C bus
    address (as with ``apds9960@39`` and its devicetree siblings), a SPI chip
    select line, or some other value depending on the kind of device the node
    represents.

This tree has the following DTS.

.. code-block:: none

   / {
           soc {
                   i2c@40003000 {
                           compatible = "nordic,nrf-twim";
                           label = "I2C_0";
                           reg = <0x40003000 0x1000>;

                           apds9960@39 {
                                   compatible = "avago,apds9960";
                                   label = "APDS9960";
                                   reg = <0x39>;
                           };
                           ti_hdc@43 {
                                   compatible = "ti,hdc", "ti,hdc1010";
                                   label = "HDC1010;
                                   reg = <0x43>;
                           };
                           mma8652fc@1d {
                                   compatible = "nxp,fxos8700", "nxp,mma8652fc";
                                   label = "MMA8652FC";
                                   reg = <0x1d>;
                           };
                   };
           };
   };

Input and output files
**********************

s section describes the input and output files shown in the figure at the
:ref:`top of this page <devicetree-intro>` in more detail.

.. figure:: zephyr_dt_inputs_outputs.svg
   :figclass: align-center

   Devicetree input (green) and output (yellow) files

.. note::

   For a higher-level overview over of the build, see :ref:`the build overview
   <build_overview>`.

DTS files usually have a :file:`.dts`, :file:`.dtsi` (*i* for *include*), or
:file:`.overlay` extension. The C preprocessor is run on all devicetree files
to expand macro references. :file:`.dts` files usually include :file:`.dtsi`
files via the C preprocessor with ``#include``.

.. note::

   DTS also has a native mechanism, ``/include/ "<filename>"``, for including
   other files, though it is less commonly used.

Each board has a base devicetree, stored in the board's directory in
:file:`boards/` as :file:`<BOARD>.dts`. This base devicetree can be extended or
modified with one or more *overlays* -- DTS files with a :file:`.overlay`
extension. Overlays adapt the base devicetree for different board variants or
applications. Along with :ref:`kconfig`, this makes it possible to reconfigure
the kernel and device drivers without modifying source code.

The build system automatically picks up :file:`.overlay` files stored in
certain locations. It is also possible to explicitly list the overlays to
include, via the :makevar:`DTC_OVERLAY_FILE` CMake variable. See
:ref:`application_dt` and :ref:`important-build-vars` for details.

After running the C preprocessor, the resulting :file:`<BOARD>.dts` and
:file:`.overlay` files are combined by concatenating them, with the overlays
put last. This relies on DTS merging multiple definitions of nodes. See
:ref:`dt_k6x_example` for an example of how this works (in the context of
``.dtsi`` files, but the principle is the same for overlays). Putting the
contents of the :file:`.overlay` files last allows them to override properties
from the base devicetree, if needed.

.. note::

   These files in the build directory can be useful as a debugging aid when
   working with devicetree:

   zephyr/<BOARD>.dts.pre.tmp
       The preprocessed and concatenated DTS sources

   zephyr/zephyr.dts
       The final merged devicetree. This file is specifically output as a
       debugging aid, and is unused otherwise.

The merged devicetree, along with any :ref:`dt-bindings` referenced
from it, is used to generate C preprocessor macros. This is handled by the
libraries and scripts listed below, located in :zephyr_file:`scripts/dts/`.
Note that the source code has extensive comments and documentation.

:zephyr_file:`dtlib.py <scripts/dts/dtlib.py>`
    A low-level DTS parsing library

:zephyr_file:`edtlib.py <scripts/dts/edtlib.py>`
    A library layered on top of dtlib that uses bindings to interpret
    properties and give a higher-level view of the devicetree. Uses dtlib to do
    the DTS parsing.

:zephyr_file:`gen_defines.py <scripts/dts/gen_defines.py>`
    A script that uses edtlib to generate C preprocessor macros from the
    devicetree and bindings.

The output from :file:`gen_defines.py` is stored in
:file:`include/generated/devicetree_unfixed.h` in the build directory.

.. note::

   In addition to the Python code above, the standard ``dtc`` DTS compiler is
   also run on the devicetree. This is just to catch any errors or warnings it
   generates. The output is unused.

Most devices currently use :file:`dts_fixup.h` files that rename macros from
:file:`devicetree_unfixed.h` to names that are more meaningful for the
device. By default, these fixup files are in the :file:`board/` and
:file:`soc/` directories. Any :file:`dts_fixup.h` files are concatenated and
stored as :file:`include/devicetree_fixups.h` in the build directory.

Fixup files exist for historical reasons, and Zephyr might move away from using
them. When writing new code, feel free to create any macro aliases you need in
whatever way is handiest for the code.

To reference macros generated from devicetree, code should include the
:file:`devicetree.h` header, which appears on the C preprocessor include path.
This file appears at :zephyr_file:`include/devicetree.h` and is not a generated
file. It includes the generated :file:`include/devicetree_unfixed.h` and
:file:`include/devicetree_fixups.h` files.

.. warning::

   Do not include the generated C headers from the build directory directly.
   Include :file:`devicetree.h` instead.

Since some boards may need special instructions for the device tree compiler
(e.g. warning suppression), create a file named ``pre_dt_board.cmake`` inside
the board's folder and add the extra flags inside.

.. code-block:: cmake

   list(APPEND EXTRA_DTC_FLAGS "-Wno-simple_bus_reg")

Source Tree Hierarchy
*********************

The devicetree files are located in a couple of different directories.  The
directory split is done based on architecture, and there is also a common
directory where architecture agnostic devicetree and YAML binding files are
located.

Assuming the current working directory is the ZEPHYR_BASE, the directory
hierarchy looks like the following::

  dts/common/
  dts/<ARCH>/
  dts/bindings/
  boards/<ARCH>/<BOARD>/

The common directory contains a ``skeleton.dtsi`` which provides devicetree root
node definition.  The bindings subdirectory contains YAML binding files used
to instruct how the python DTS parsing script should extract nodes information
in a format that will be usable by the system.

Example: Subset of DTS/YAML files for NXP FRDM K64F (Subject to Change)::

  dts/arm/armv7-m.dtsi
  dts/arm/k6x/nxp_k6x.dtsi
  boards/arm/frdm_k64f/frdm_k64f.dts
  dts/bindings/interrupt-controller/arm,v7m-nvic.yaml
  dts/bindings/gpio/nxp,kinetis-gpio.yaml
  dts/bindings/pinctrl/nxp,kinetis-pinmux.yaml
  dts/bindings/serial/nxp,kinetis-uart.yaml

