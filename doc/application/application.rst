.. _application:

Application Development Primer
##############################

.. note::

   In this document, we'll assume your **application directory** is
   :file:`~/app`, and that its **build directory** is :file:`~/app/build`.
   (These terms are defined in the following Overview.)

Overview
********

Zephyr's build system is based on CMake.

The build system is application-centric, and requires Zephyr-based applications
to initiate building the kernel source tree. The application build controls
the configuration and build process of both the application and Zephyr itself,
compiling them into a single binary.

Zephyr's base directory hosts Zephyr's own source code, its kernel
configuration options, and its build definitions.

The files in the **application directory** link Zephyr with the
application. This directory contains all application-specific files, such as
configuration options and source code.

An application in its simplest form has the following contents:

.. code-block:: none

   ~/app
   ├── CMakeLists.txt
   ├── prj.conf
   └── src
       └── main.c

These contents are:

* **CMakeLists.txt**: This file tells the build system where to find the other
  application files, and links the application directory with Zephyr's CMake
  build system. This link provides features supported by Zephyr's build system,
  such as board-specific kernel configuration files, the ability to run and
  debug compiled binaries on real or emulated hardware, and more.

* **Kernel configuration files**: An application typically provides
  a configuration file (ending in :file:`.conf`) that specifies values for one
  or more kernel configuration options. If omitted, the application's existing
  kernel configuration option values are used; if no existing values are
  provided, the kernel's default configuration values are used.

* **Application source code files**: An application typically provides one
  or more application-specific files, written in C or assembly language. These
  files are usually located in a sub-directory called :file:`src`.

Once an application has been defined, project files for building it can be
generated by calling ``cmake ~/app``. Project files will be written to the
directory where ``cmake`` is called. This directory is known as the
**build directory**.

The most notable files in the build directory are:

* :file:`build.ninja` (or :file:`Makefile`), which can be invoked to build
  the application.

* A :file:`zephyr` directory, which is the working directory of the
  generated build system, and where most generated files are created and
  stored.

After the underlying build tool has been invoked, the following build output
files will be written to the :file:`zephyr` sub-directory of the build
directory. (This is different than the Zephyr base directory, which contains
the Zephyr source code etc. and is described above.)

* :file:`.config`, which contains the configuration settings
  used to build the application.

* Various object files (:file:`.o` files and :file:`.a` files) containing
  compiled kernel and application code.

* :file:`zephyr.elf`, which contains the final combined application and
  kernel binary. Other binary output formats, such as :file:`.hex` and
  :file:`.bin`, are also supported.


Creating an Application
***********************


Follow these steps to create a new application directory. (Refer to
:ref:`samples-and-demos` for existing applications provided as part of Zephyr.)

#. Create an application directory on your workstation computer, outside of the
   Zephyr base directory.  Usually you'll want to create it somewhere under
   your user's home directory.

   For example, in a Unix shell, navigate to a location where you want your
   application to reside, then enter:

   .. code-block:: console

      $ mkdir app

#. It's recommended to place all application source code in a subdirectory
   named :file:`src`.  This makes it easier to distinguish between project
   files and sources.

   Continuing the Unix shell example from the previous step, enter:

   .. code-block:: console

      $ cd app
      $ mkdir src

#. Create a :file:`CMakeLists.txt` file in your application directory with the
   following contents:

   .. code-block:: cmake

      include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
      project(NONE)

#. Place your application source code in the :file:`src` sub-directory. For
   this example, we'll assume you created a file named :file:`src/main.c`.

#. Add your source code files to the ``app`` target in your application
   directory's :file:`CMakeLists.txt`. For example, to add :file:`src/main.c`,
   add the following line to your :file:`CMakeLists.txt`:

   .. code-block:: cmake

      target_sources(app PRIVATE src/main.c)

#. Create one or more files containing your application's configuration
   options. Zephyr's configuration uses the same Kconfig system used by the
   Linux kernel, but with its own configuration tree.

   If you followed the above steps, you can now create a file named
   ``prj.conf`` in your application directory. It will be used automatically by
   the Zephyr build system.

   More information on Zephyr configuration is available below.

Applications integrate with the Zephyr build system using the boilerplate code
shown above in :file:`CMakeLists.txt`. The following important variables
configure the Zephyr build system:

* :makevar:`ZEPHYR_BASE`: Sets the path to the Zephyr base directory.  This is
  usually an environment variable set by the :file:`zephyr-env.sh` script, as
  you learned when getting started with Zephyr in
  :ref:`getting_started_run_sample`. You can also select a specific Zephyr base
  directory by replacing ``$ENV{ZEPHYR_BASE}`` with the specific base you'd
  like to use instead.

* :makevar:`BOARD`: Selects the board that the application's build will use for
  the default configuration. This can be defined in the environment, in your
  application's :file:`CMakeLists.txt` file, or in the ``cmake`` command line.

* :makevar:`CONF_FILE`: Indicates the name of one or more configuration
  fragment files.  Each file includes kconfig configuration values that
  override the default configuration values.  Like :makevar:`BOARD`, this can
  also be defined in the environment, in your application's
  :file:`CMakeLists.txt` file, or in the ``cmake`` command line.

The following sections provide more details on Zephyr's use of CMake, how to
manage your application's configuration, and how to build and run it.


CMake
*********

Overview
========

CMake is used to build Zephyr. A CMake build is done in two
stages. The first stage is called Configuration, during Configuration
the CMakeLists.txt build scripts are executed. At the end of
Configuration, CMake will have an internal model of the Zephyr build
and can generate build scripts that are native to the host platform.

CMake supports generating several build systems, but only Ninja and
Make are tested and supported by Zephyr. After Configuration and
Generation the user can begin the Build stage by executing the
generated build system. The build system will for most code changes be
able to re-build the application without involving CMake. But for
certain configuration changes the Configuration step will need to be
executed again, either automatically by the build system, or even
manually in some cases.

Zephyr uses CMake's concept of a 'target' to organize the build. A
target can be an executable, a library, or a generated file. For
application developers, the library target is the most important to
understand. All source code that goes into a Zephyr build does so by
being included in a library target, even application code.

Library targets have source code, that is added through CMakeLists.txt
build scripts like this:

.. code-block:: cmake

   target_sources(app PRIVATE src/main.c)

In the above code an existing library target named 'app' is being
configured to have the source file src/main.c. The PRIVATE keyword
indicates that we are modifying the internals of how the library is
being built. Whereas using the keyword 'PUBLIC' would modify how other
libraries that link with app are built. In this case, using PUBLIC
here would cause libraries that link with app to also include the
source file src/main.c, behaviour that we surely do not want. The
'PUBLIC' keyword could however be useful when modifying the include
paths of a target library.

Application CMakeLists.txt
**************************

Every application must have a CMakeLists.txt file. The application
CMakeLists.txt file is the entry point, or toplevel of the build
system that builds the :file:`zephyr.elf` image. :file:`zephyr.elf`
contains both the application and the kernel libraries.

#. Open the :file:`CMakeLists.txt` and add the following mandatory
   entries using any text editor.

#. Add the name of the board configuration for your application on a
   new line:

   .. code-block:: cmake

      set(BOARD qemu_x86)

   The supported boards can be found in :ref:`boards`.

#. Include the mandatory boilerplate that integrates the application
   with the Zephyr build system on a new line:

   .. code-block:: cmake

      include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
      project(NONE)

#. Add any application source files to the 'app' target library:

   .. code-block:: cmake

      target_sources(app PRIVATE src/main.c)

#. Save and close the :file:`CMakeLists.txt`.

Below is an example CMakeList.txt:

.. code-block:: cmake

   set(BOARD qemu_x86)

   include($ENV{ZEPHYR_BASE}/cmake/app/boilerplate.cmake NO_POLICY_SCOPE)
   project(NONE)

   target_sources(app PRIVATE src/main.c)

.. _application_configuration:

Application Configuration
*************************

The application's kernel is configured using a set of configuration options
that can be customized for application-specific purposes.
The Zephyr build system takes a configuration option's value from the first
source in which it is specified.

The available sources are (in order):

#. The application's current configuration. (i.e. The :file:`.config` file.)

#. The application's default configuration. (Specified by ``CONF_FILE``, i.e. :file:`prj.conf`.)

#. The board configuration used by the application.
   (i.e. The board's :file:`_defconfig` file.)

#. The kernel's default configuration.
   (i.e. One of the kernel's :file:`Kconfig` files.)

For information on available kernel configuration options, including
inter-dependencies between options, see the :ref:`configuration`.

Default Board Configuration
===========================

An application's :file:`.conf` file defines its default kernel configuration.
The settings in this file override or augment the board configuration settings.

The board configuration settings can be viewed
in :file:`$ZEPHYR_BASE/boards/ARCHITECTURE/BOARD/BOARD_defconfig`.

.. note::

   When the default board configuration settings are sufficient for your
   application, a :file:`.conf` file is not needed. Skip ahead to
   :ref:`override_kernel_conf`.


#. Navigate to the :file:`app`, and create the :file:`prj.conf` file. Enter:

   .. code-block:: bash

       $ vim prj.conf

   The application's default configuration is specified by
   ``CONF_FILE``, ``CONF_FILE`` defaults to :file:`prj.conf` unless
   configured otherwise in the application :file:`CMakeLists.txt`
   file.

#. Edit the file and add the appropriate configuration entries.

   a) Add each configuration entry on a new line.

   b) Begin each entry with ``CONFIG_``.

   c) Ensure that each entry contains no spaces
      (including on either side of the = sign).

   d) Use a # followed by a space to comment a line.

   The example below shows a comment line and a board
   configuration override in the :file:`prj.conf`.

   .. code-block:: c

       # Enable printk for debugging
       CONFIG_PRINTK=y

#. Save and close the file.

.. _override_kernel_conf:

Overriding Default Configuration
================================

Override the default board and kernel configuration to temporarily alter the
application's configuration, perhaps to test the effect of a change.

.. note::

   If you want to permanently alter the configuration you
   should revise the :file:`.conf` file.

Configure the kernel options using a menu-driven interface. While you can add
entries manually, using the configuration menu is a preferred method.


#. After generating project files run :command:`ninja menuconfig` to launch the menu-driven interface.

   a) In a terminal session, navigate to the application directory
      (:file:`~/app`).

   b) Enter the following command:

      .. code-block:: bash

          $ cmake -Bbuild -H. -GNinja
          $ ninja -C build menuconfig

      A question-based menu opens that allows you to set individual configuration
      options.

      .. image:: figures/app_kernel_conf_1.png
           :width: 600px
           :align: center
           :alt: Main Configuration Menu

#. Set kernel configuration values using the following
   key commands:

   * Use the arrow keys to navigate within any menu or list.

   * Press :kbd:`Enter` to select a menu item.

   * Type an upper case :kbd:`Y` or :kbd:`N` in the
      square brackets :guilabel:`[ ]` to
      enable or disable a kernel configuration option.

   * Type a numerical value in the round brackets :guilabel:`( )`.

   * Press :kbd:`Tab` to navigate the command menu at the bottom of the display.

     .. note::

       When a non-default entry is selected for options that are non-numerical,
       an asterisk :kbd:`*` appears between the square brackets in the display.
       There is nothing added added the display when you select the option's
       default.

#. For information about any option, select the option and tab to
   :guilabel:`<Help >` and press :kbd:`Enter`.

   Press :kbd:`Enter` to return to the menu.

#. After configuring the kernel options for your application, tab to
   :guilabel:`< Save >` and press :kbd:`Enter`.

   The following dialog opens with the :guilabel:`< Ok >` command selected:

   .. image:: figures/app_kernel_conf_2.png
      :width: 400px
      :align: center
      :height: 100px
      :alt: Save Configuration Dialog


#. Press :kbd:`Enter` to save the kernel configuration options to the default
   file name; alternatively, type a file name and press :kbd:`Enter`.

   Typically, you will save to the default file name unless you are
   experimenting with various configuration scenarios.

   A :file:`zephyr` directory will have been created in the build
    directory.

   .. note::

      At present, only a :file:`.config` file can be built. If you have saved
      files with different file names and want to build with one of these,
      change the file name to :file:`.config`. To keep your original
      :file:`.config`, rename it to something other than :file:`.config`.

   Kernel configuration files, such as the :file:`.config` file, are saved
   as hidden files in :file:`zephyr`. To list all your kernel configuration
   files, enter :command:`ls -a` at the terminal prompt.

   The following dialog opens, displaying the file name the configuration
   was saved to.

   .. image:: figures/app_kernel_conf_3.png
         :width: 400px
         :align: center
         :height: 150px
         :alt: Saved Configuration Name Dialog

#. Press :kbd:`Enter` to return to the options menu.

#. To load any saved kernel configuration file, tab to :guilabel:`< Load >` and
   press :kbd:`Enter`.

   The following dialog opens with the :guilabel:`< Ok >` command selected:

   .. image:: figures/app_kernel_conf_4.png
      :width: 400px
      :align: center
      :height: 175px
      :alt: Configuration File Load Dialog

#. To load the last saved kernel configuration file, press :guilabel:`< Ok >`,
   or to load another saved configuration file, type the file name, then select
   :guilabel:`< Ok >`.

#. Press :kbd:`Enter` to load the file and return to the main menu.

#. To exit the menu configuration, tab to :guilabel:`< Exit >` and press
   :kbd:`Enter`.

   The following confirmation dialog opens with the :guilabel:`< Yes >`
   command selected.

   .. image:: figures/app_kernel_conf_5.png
      :width: 400px
      :align: center
      :height: 100px
      :alt: Exit Dialog

#. Press :kbd:`Enter` to retire the menu display and return to the console
   command line.

Application-Specific Code
*************************

Application-specific source code files are normally added to the
application's :file:`src` directory. If the application adds a large
number of files the developer can group them into sub-directories
under :file:`src`, to whatever depth is needed.

Application-specific source code should not use symbol name prefixes that have
been reserved by the kernel for its own use. For more information, see

`Naming Conventions
<https://github.com/zephyrproject-rtos/zephyr/wiki/Naming-Conventions>`_.

Support for building third-party library code
=============================================

It is possible to build library code outside the application's :file:`src`
directory but it is important that both application and library code targets
the same Application Binary Interface (ABI). On most architectures there are
compiler flags that control the ABI targeted, making it important that both
libraries and applications have certain compiler flags in common. It may also
be useful for glue code to have access to Zephyr kernel header files.

To make it easier to integrate third-party components, the Zephyr
build system has defined CMake functions that give application build
scripts access to the zephyr compiler options. The functions are
documented and defined in :file:`$ZEPHYR_BASE/cmake/extensions.cmake`
and follow the naming convention ``zephyr_get_<type>_<format>``.

The following variables will often need to be exported to the
third-party build system.

* ``CMAKE_C_COMPILER``, ``CMAKE_AR``.

* ``ARCH`` and ``BOARD``, together with several variables that identify the
  Zephyr kernel version.

:file:`samples/application_development/external_lib` is a sample
project that demonstrates some of these features.

.. _build_an_application:

Build an Application
********************

The Zephyr build system compiles and links all components of an application
into a single application image that can be run on simulated hardware or real
hardware.


#. Navigate to the application directory :file:`~/app`.

#. Enter the following commands to build the application's
   :file:`zephyr.elf` image using the configuration settings for the
   board type specified in the application's :file:`CMakeLists.txt`.

   .. code-block:: console

       $ mkdir build
       $ cd build
       $ cmake -GNinja ..
       $ ninja

   If desired, you can build the application using the configuration settings
   specified in an alternate :file:`.conf` file using the :code:`CONF_FILE`
   parameter. These settings will override the settings in the application's
   :file:`.config` file or its default :file:`.conf` file. For example:

   .. code-block:: console


       $ export CONF_FILE=prj.alternate.conf
       $ cmake -GNinja ..

   If desired, you can generate project files for a different board
   type than the one specified in the application's
   :file:`CMakeLists.txt` by defining the environment variable
   :code:`BOARD`.

   Both the :code:`CONF_FILE` and :code:`BOARD` parameters can be specified
   when building the application.

Rebuilding an Application
*************************

Application development is usually fastest when changes are continually tested.
Frequently rebuilding your application makes debugging less painful
as the application becomes more complex. It's usually a good idea to
rebuild and test after any major changes to the application's source files,
CMakeLists.txt files, or configuration settings.

.. important::

    The Zephyr build system rebuilds only the parts of the application image
    potentially affected by the changes. Consequently, rebuilding an application
    is often significantly faster than building it the first time.

Sometimes the build system doesn't rebuild the application correctly
because it fails to recompile one or more necessary files. You can force
the build system to rebuild the entire application from scratch with the
following procedure:


#. Navigate to the build directory :file:`~/app/build`.

#. Enter the following command to delete the application's generated
   files, except for the :file:`.config` file that contains the
   application's current configuration information.

   .. code-block:: console

       $ ninja clean

   Alternatively, enter the following command to delete *all*
   generated files, including the :file:`.config` files that contain
   the application's current configuration information for those board
   types.

   .. code-block:: console

       $ ninja pristine

#. Rebuild the application normally following the steps specified
   in `Build an Application`_ above.

.. _application_run:

Run an Application
******************

An application image can be run on real or emulated hardware.

Most boards supported by Zephyr let you flash a compiled binary using
the Make ``flash`` target to copy the binary to the board and run it.
Follow these instructions to flash and run an application on real
hardware:

#. Open a terminal console on your host computer, and navigate to the
   application directory, :file:`~/app`.

#. Enter the following command to build and run the application on
   your board, which you will usually attach via USB.

   .. code-block:: console

       $ make [BOARD=<type> ...] flash

   The Zephyr build system integrates with the board support files to
   use hardware-specific tools to flash the Zephyr binary to your
   hardware, then run it.

   In cases where board support is incomplete, ``make flash`` may not
   be supported. If you receive an error message about flash support
   being unavailable when running this command, consult :ref:`your
   board's documentation <boards>` for additional information on how
   to flash your board.

.. note:: When developing on Linux, it's common to need to install
          board-specific udev rules to enable USB device access to
          your board as a non-root user. If ``make flash`` fails,
          consult your board's documentation to see if this is
          necessary.

The kernel has built-in emulator support for QEMU. It allows you to
run and test an application virtually, before (or in lieu of) loading
and running it on actual target hardware. Follow these instructions to
run an application via QEMU:

#. Open a terminal console on your host computer, and navigate to the
   application directory :file:`~/app`.

#. After generating project files for a QEMU-supported board
   configuration, such as qemu_cortex_m3 or qemu_x86, enter the
   following command to build and run the application.

   .. code-block:: console

       $ ninja run

   The Zephyr build system generates a :file:`zephyr.elf` image file
   and then begins running it in the terminal console.

#. Press :kbd:`Ctrl A, X` to stop the application from running
   in QEMU.

   The application stops running and the terminal console prompt
   redisplays.

.. _application_debugging:

Application Debugging
*********************

This section is a quick hands-on reference to start debugging your
application with QEMU. Most content in this section is already covered on
`QEMU`_ and `GNU_Debugger`_ reference manuals.

.. _QEMU: http://wiki.qemu.org/Main_Page

.. _GNU_Debugger: http://www.gnu.org/software/gdb

In this quick reference you find shortcuts, specific environmental variables and
parameters that can help you to quickly set up your debugging environment.

The simplest way to debug an application running in QEMU is using the GNU
Debugger and setting a local GDB server in your development system through QEMU.

You will need an ELF binary image for debugging purposes.  The build system
generates the image in the build directory.  By default, the kernel binary name
is :file:`zephyr.elf`. The name can be changed using a Kconfig option.

We will use the standard 1234 TCP port to open a :abbr:`GDB (GNU Debugger)`
server instance. This port number can be changed for a port that best suits the
development environment.

You can run Qemu to listen for a "gdb connection" before it starts executing any
code to debug it.

.. code-block:: bash

   qemu -s -S <image>

will setup Qemu to listen on port 1234 and wait for a GDB connection to it.

The options used above have the following meaning:

* ``-S`` Do not start CPU at startup; rather, you must type 'c' in the
  monitor.
* ``-s`` Shorthand for :literal:`-gdb tcp::1234`: open a GDB server on
  TCP port 1234.

To debug with QEMU and to start a GDB server and wait for a remote connect, run
the following inside the build directory of an application:

.. code-block:: bash

   ninja debugserver

The build system will start a QEMU instance with the CPU halted at startup
and with a GDB server instance listening at the TCP port 1234.

Using a local GDB configuration :file:`.gdbinit` can help initialize your GDB
instance on every run.
In this example, the initialization file points to the GDB server instance.
It configures a connection to a remote target at the local host on the TCP
port 1234. The initialization sets the kernel's root directory as a
reference.

The :file:`.gdbinit` file contains the following lines:

.. code-block:: bash

   target remote localhost:1234
   dir ZEPHYR_BASE

.. note::

   Substitute ZEPHYR_BASE for the current kernel's root directory.

Execute the application to debug from the same directory that you chose for
the :file:`gdbinit` file. The command can include the ``--tui`` option
to enable the use of a terminal user interface. The following commands
connects to the GDB server using :file:`gdb`. The command loads the symbol
table from the elf binary file. In this example, the elf binary file name
corresponds to :file:`zephyr.elf` file:

.. code-block:: bash

   $ gdb --tui zephyr.elf

.. note::

   The GDB version on the development system might not support the --tui
   option.

If you are not using a .gdbinit file, issue the following command inside GDB to
connect to the remove GDB server on port 1234:

.. code-block:: bash

   (gdb) target remote localhost:1234

Finally, The command below connects to the GDB server using the Data
Displayer Debugger (:file:`ddd`). The command loads the symbol table from the
elf binary file, in this instance, the :file:`zephyr.elf` file.

The :abbr:`DDD (Data Displayer Debugger)` may not be installed in your
development system by default. Follow your system instructions to install
it.

.. code-block:: bash

   ddd --gdb --debugger "gdb zephyr.elf"


Both commands execute the :abbr:`gdb (GNU Debugger)`. The command name might
change depending on the toolchain you are using and your cross-development
tools.
